<!doctype html>
<html>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/common/get-host-info.sub.js"></script>
<script src="/service-workers/service-worker/resources/test-helpers.sub.js"></script>
<script>

promise_test(async (t) => {
  const SCOPE = new URL(location.href).pathname;
  const SCRIPT =
    'resources/sw-store-to-cache-storage.js?' +
    `pipe=header(service-worker-allowed,${SCOPE})`;

  const reg = await service_worker_unregister_and_register(t, SCRIPT, SCOPE);
  add_completion_callback(() => reg.unregister());
  await new Promise(resolve => {
    navigator.serviceWorker.addEventListener('controllerchange', resolve);
  });
  t.done();
}, 'setting up');

function remote(path) {
  const REMOTE_ORIGIN = get_host_info().HTTPS_REMOTE_ORIGIN;
  return new URL(path, REMOTE_ORIGIN);
}

function local(path) {
  return new URL(path, location.origin);
}

// Send a message to the currently active ServiceWorker and wait for its response.
function serviceWorkerRequest(message) {
  return new Promise(resolve => {
    navigator.serviceWorker.addEventListener('message', e => resolve(e.data));
    navigator.serviceWorker.controller.postMessage(message);
  });
}

// Load an image from the |response|. Return "loaded" or "error" depending on
// its load result.
async function readImageFromResponse(response) {
  let blob = await response.blob();
  let img = document.createElement("img");
  img.src = URL.createObjectURL(blob);
  let img_load = new Promise(resolve => img.onload = resolve.bind(this, "loaded"));
  let img_error = new Promise(resolve => img.onerror = resolve.bind(this, "error"));
  document.body.appendChild(img);
  return await Promise.race([img_load, img_error]);
}

const CORP_UNDEFINED = "images/blue.png";
const CORP_SAME_ORIGIN = "images/blue.png?pipe=header(Cross-Origin-Resource-Policy, same-origin)";
const CORP_CROSS_ORIGIN = "images/blue.png?pipe=header(Cross-Origin-Resource-Policy, cross-origin)";

promise_test(async (t) => {
  // 0. Start from an empty CacheStorage.
  assert_equals(await serviceWorkerRequest("clear"), "cleared");

  // 1. Store a cross-origin no-cors response generated from the SW into the
  //    CacheStorage.
  const url = remote("sw-generated.png");
  let request = {
    url: url.href,
    mode: "no-cors",
    source: "service-worker",
  };
  assert_equals(await serviceWorkerRequest(request), "stored");

  // 2. Retrieve it from the CacheStorage.
  const cache = await caches.open('v1');
  const response = await cache.match(url, {mode: 'no-cors'});

  assert_equals(response.type, "default");
  assert_equals(response.url, ""); // Response is SW-generated.
  assert_equals(response.ok, true);
  assert_equals(response.status, 200);
  assert_equals(await response.text(), "foo");

  t.done();
}, "Fetch cross-origin no-cors SW-generated response from CacheStorage.");

promise_test(async (t) => {
  // 0. Start from an empty CacheStorage.
  assert_equals(await serviceWorkerRequest("clear"), "cleared");

  // 1. Store a cross-origin no-cors response with CORP: same-origin into
  //    CacheStorage. It must failed, because the ServiceWorker is cross-origin
  //    with the resource and the resource use CORP: same-site.
  const url = remote(CORP_SAME_ORIGIN);
  let request = {
    url: url.href,
    mode: "no-cors",
    source: "network",
  };
  assert_equals(await serviceWorkerRequest(request), "not-stored");
}, "Fetch cross-origin no-cors with CORP: same-origin.");

promise_test(async (t) => {
  // 0. Start from an empty CacheStorage.
  assert_equals(await serviceWorkerRequest("clear"), "cleared");

  // 1. Store a cross-origin no-cors response with CORP: cross-origin into
  //    CacheStorage.
  const url = remote(CORP_CROSS_ORIGIN);
  let request = {
    url: url.href,
    mode: "no-cors",
    source: "network",
  };
  assert_equals(await serviceWorkerRequest(request), "stored");

  // 2. Retrieve it from the CacheStorage.
  const cache = await caches.open('v1');
  const response = await cache.match(url, {mode: 'no-cors'});

  // The request is non-cors and the response is cross-origin. Hence the
  // response is opaque and can't be read directly from this document.
  assert_equals(response.type, "opaque");
  assert_equals(response.url, "");
  assert_equals(response.ok, false);
  assert_equals(response.status, 0);
  assert_equals(response.body, null);

  // TODO(arthursonzogni): Why can't we load the image from the opaque response?
  assert_equals(await readImageFromResponse(response), "error");

  t.done();
}, "Fetch cross-origin no-cors with CORP: cross-origin from CacheStorage.");

promise_test(async (t) => {
  // 0. Start from an empty CacheStorage.
  assert_equals(await serviceWorkerRequest("clear"), "cleared");

  // 1. Store a cross-origin no-cors response with CORP: cross-origin into
  //    CacheStorage.
  const url = remote(CORP_UNDEFINED);
  let request = {
    url: url.href,
    mode: "no-cors",
    source: "network",
  };
  assert_equals(await serviceWorkerRequest(request), "stored");

  // 2. Retrieve it from the CacheStorage.
  const cache = await caches.open('v1');
  const response = await cache.match(url, {mode: 'no-cors'});

  // The request is no-cors and the response is cross-origin. Hence the response
  // is opaque to this document. It can't be read directly.
  assert_equals(response.type, "opaque");
  assert_equals(response.url, "");
  assert_equals(response.ok, false);
  assert_equals(response.status, 0);
  assert_equals(response.body, null);

  // Because this document has COEP: require-corp and the response do not
  // specify a CORS header, the image can't be read.
  // TODO(arthursonzogni): Figure out if this is failing for good reasons.
  assert_equals(await readImageFromResponse(response), "error");

  t.done();
}, "Fetch cross-origin no-cors with CORP: undefined from CacheStorage.");

promise_test(async (t) => {
  // 0. Start from an empty CacheStorage.
  assert_equals(await serviceWorkerRequest("clear"), "cleared");

  // 1. Store a same-origin no-cors response generated from the SW into the
  //    CacheStorage.
  const url = local("sw-generated.png");
  let request = {
    url: url.href,
    mode: "no-cors",
    source: "service-worker",
  };
  assert_equals(await serviceWorkerRequest(request), "stored");

  // 2. Retrieve it from the CacheStorage.
  const cache = await caches.open('v1');
  const response = await cache.match(url, {mode: 'no-cors'});

  assert_equals(response.type, "default");
  assert_equals(response.url, ""); // Response is SW-generated.
  assert_equals(response.ok, true);
  assert_equals(response.status, 200);
  assert_equals(await response.text(), "foo");

  t.done();
}, "Fetch same-origin no-cors SW-generated response from CacheStorage.");

promise_test(async (t) => {
  // 0. Start from an empty CacheStorage.
  assert_equals(await serviceWorkerRequest("clear"), "cleared");

  // 1. Store a same-origin no-cors response with CORP: cross-origin into
  //    CacheStorage. It must succeed.
  const url = local(CORP_SAME_ORIGIN);
  let request = {
    url: url.href,
    mode: "no-cors",
    source: "network",
  };
  assert_equals(await serviceWorkerRequest(request), "stored");

  // 2. Retrieve it from the CacheStorage.
  const cache = await caches.open('v1');
  const response = await cache.match(url, {mode: 'no-cors'});

  // A same-origin response can always be loaded.
  assert_equals(response.type, "basic");
  assert_equals(response.url, url.href);
  assert_equals(response.ok, true);
  assert_equals(response.status, 200);

  assert_equals(await readImageFromResponse(response), "loaded");

  t.done();
}, "Fetch same-origin no-cors with CORP: same-origin.");

promise_test(async (t) => {
  // 0. Start from an empty CacheStorage.
  assert_equals(await serviceWorkerRequest("clear"), "cleared");

  // 1. Store a same-origin no-cors response with CORP: cross-origin into
  //    CacheStorage.
  const url = local(CORP_CROSS_ORIGIN);
  let request = {
    url: url.href,
    mode: "no-cors",
    source: "network",
  };
  assert_equals(await serviceWorkerRequest(request), "stored");

  // 2. Retrieve it from the CacheStorage.
  const cache = await caches.open('v1');
  const response = await cache.match(url, {mode: 'no-cors'});

  // A same-origin response can always be loaded.
  assert_equals(response.type, "basic");
  assert_equals(response.url, url.href);
  assert_equals(response.ok, true);
  assert_equals(response.status, 200);

  assert_equals(await readImageFromResponse(response), "loaded");

  t.done();
}, "Fetch same-origin no-cors with CORP: cross-origin from CacheStorage.");

promise_test(async (t) => {
  // 0. Start from an empty CacheStorage.
  assert_equals(await serviceWorkerRequest("clear"), "cleared");

  // 1. Store a same-origin no-cors response with CORP: cross-origin into
  //    CacheStorage.
  const url = local(CORP_UNDEFINED);
  let request = {
    url: url.href,
    mode: "no-cors",
    source: "network",
  };
  assert_equals(await serviceWorkerRequest(request), "stored");

  // 2. Retrieve it from the CacheStorage.
  const cache = await caches.open('v1');
  const response = await cache.match(url, {mode: 'no-cors'});

  // A same-origin response can always be loaded.
  assert_equals(response.type, "basic");
  assert_equals(response.url, url.href);
  assert_equals(response.ok, true);
  assert_equals(response.status, 200);

  assert_equals(await readImageFromResponse(response), "loaded");

  t.done();
}, "Fetch same-origin no-cors with CORP: undefined from CacheStorage.");

</script>
</html>
